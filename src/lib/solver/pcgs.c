#include <stdio.h>
#include <estiva/ary.h>
#include <estiva/mx.h>
#include <estiva/solver.h>

typedef long*    I_  ;
typedef long**   I__ ;
typedef double*  D_  ;
typedef double** D__ ;

#define D_  static D_
#define D__ static D__
#define I_  static I_
#define I__ static I__

static int count_NL(void *pA, long N)
{
  long i, j, k, NL ;

  for(NL=0, i=1; i<=N; i++){
    for(k=0, j=1; j<=N; j++) if(mx(pA,i,j) != 0.0) k++;
    if(NL<k) NL = k;
  }
  return NL;
}

static int pcgs();

int estiva_pcgssolver(void* pA, double* x, double* b)
{

  /* (i)  引数の型と種類                                                */
  D_     D, B         ;/*    D  一次元配列 D(N), B(N)                   */
  D__    A            ;/*    D  二次元配列 A(N1, 2 * NL)                */
  I__    IA           ;/*    I  二次元配列 IA(N1, 2 * NL)               */
  D_     R            ;/*    D  一次元配列 R(N)                         */
  long   NL, N1, N, ITR, IER                                            ;
  double EPS, S                                                         ;
  D_     X, DD, P, Q  ;/*    D  一次元配列で, 要素は 0〜N               */
  I_     M            ;/*    I  一次元配列  M(2 * N)  作業用            */

  /*--    DからRまでと, EPSからSまでの引数は, サブルーチンPCGと同じ   --*/  

  D_     R0, E, H     ;/*    D  一次元配列  要素数はN                   */
  D_     W            ;/*    D  一次元配列  W(0:N)                      */
  
  long   i, j, k      ;
  
  N   = dim1(b)       ;
  NL  = count_NL(pA,N);
  
  ary1(  D, N   )         ;
  ary2(  A, 2*NL, N+2*NL );
  ary2( IA, 2*NL, N+2*NL );
  ary1(  R, N   )         ;
  ary1(  X, N+1 )         ;  ary1( DD, N+1 );  ary1( P, N+1 );  ary1( Q, N+1 ); 
  ary1(  M, 2*N )         ;

  ary1( R0, N   )         ;  ary1(  E, N   );  ary1( H, N   );
  ary1(  W, N+1 )         ;
  

  /* (ii) 主プログラム → サブルーチン                                  */
  /*      サブルーチンをCALLするときには, つぎの値を与える.             */
  /*  D   : 配列Dの第1〜第n位置に行列Aの対角要素を入れておく            */
  /*  N   : 行列Aの行数を入れておく.                                    */
  /*  N1  : 配列Aの行数を入れておく. N1≧N+2*NL でないといけない.       */
  /*  NL  : 行列Aの各行における非ゼロ要素数の最大値を入れておく.        */
  /*  B   : 連立一次方程式の右辺を入れておく.                           */
  /* EPS  : 収束判定置を入れておく. ふつうは 1.×10^(-7)                */
  /* ITR  : 打切りまでの最大繰返し回数を入れておく.                     */

  /*--    D, N, N1, NL, B, EPS, ITR については, サブルーチンPCGと同じ --*/

  /*  A   : 配列Aの各行1〜NL要素は, 行列Aの下三角部分の各行の非ゼロ     */
  /*        要素を入れる. また, 各行のNL+1〜2*NL要素は, 上三角部分      */
  /*        の各行の非ゼロ要素を入れる. ただし, 各行の対角要素は配列Dに */
  /*        入れる.                                                     */
  /* IA   : 配列Aに入れた要素の列番号を, 対応する位置に入れておく.      */
  /*  S   : LUCGS法のとき 0., MLUCG法のときσ(>0)を入れておく.          */  

  for(i=1; i<=N; i++) D[i-1] = mx(pA,i,i); 

  for(i=1; i<=N; i++)for(k=0, j=1; j<i; j++)if(mx(pA,i,j) != 0.0){
    A[k][i-1]  = mx(pA,i,j)  ;
    IA[k][i-1] = j       ;
    k++                  ;
  }

  for(i=1; i<=N; i++)for(k=NL, j=i+1; j<=N; j++)if(mx(pA,i,j) != 0.0){
    A[k][i-1]  = mx(pA,i,j) ;
    IA[k][i-1] = j       ;
    k++                  ;
  }
      

  N1  =  N+2*NL;

  B   = &b[1]  ;
  EPS = 1.0e-7 ;
  ITR = N      ;
  S   = 0.     ;
  
  /* (a) リンクの方法                                                   */
  /* CALL PCGS(D,A,IA,N,N1,NL,B,EPS,ITR,S,X,DD,P,Q,R,R0,E,H,W,M,IER)    */

  pcgs(D,A[0],IA[0],&N,&N1,&NL,B,&EPS,&ITR,
			    &S,X,DD,P,Q,R,R0,E,H,W,M,&IER);

  B   = &x[1]  ;
  for(i=0; i<N; i++) B[i] = X[i+1];
  printf("ITR = %ld\n",ITR);
  return IER;
}

/* pcgs_.f -- translated by f2c (version 20061008).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/

/* g2c.h  --  g77 version of f2c (Standard Fortran to C header file) */

/* This file is generated by the g77 libg2c configuration process from a
   file named g2c.hin.  This process sets up the appropriate types,
   defines the appropriate macros, and so on.  The resulting g2c.h file
   is used to build g77's copy of libf2c, named libg2c, and also can
   be used when compiling C code produced by f2c to link the resulting
   object file(s) with those produced by the same version of g77 that
   produced this file, allowing inter-operability of f2c-compiled and
   g77-compiled code.  */

/**  barf  [ba:rf]  2.  "He suggested using FORTRAN, and everybody barfed."

	- From The Shogakukan DICTIONARY OF NEW ENGLISH (Second edition) */

#ifndef F2C_INCLUDE
#define F2C_INCLUDE

/* F2C_INTEGER will normally be `int' but would be `long' on 16-bit systems */
/* we assume short, float are OK */
typedef int /* long int */ integer;
typedef unsigned long int /* long */ uinteger;
typedef char *address;
typedef short int shortint;
typedef float real;
typedef double doublereal;
typedef struct { real r, i; } complex;
typedef struct { doublereal r, i; } doublecomplex;
typedef int /* long int */ logical;
typedef short int shortlogical;
typedef char logical1;
typedef char integer1;
typedef long long int /* long long */ longint;		/* system-dependent */
typedef unsigned long long int /* long long */ ulongint;	/* system-dependent */
#define qbit_clear(a,b)	((a) & ~((ulongint)1 << (b)))
#define qbit_set(a,b)	((a) |  ((ulongint)1 << (b)))

#define TRUE_ (1)
#define FALSE_ (0)

/* Extern is for use with -E */
#ifndef Extern
#define Extern extern
#endif

/* I/O stuff */

#ifdef f2c_i2
#error "f2c_i2 will not work with g77!!!!"
/* for -i2 */
typedef short flag;
typedef short ftnlen;
typedef short ftnint;
#else
typedef int /* long int */ flag;
typedef int /* long int */ ftnlen;
typedef int /* long int */ ftnint;
#endif

/*external read, write*/
typedef struct
{	flag cierr;
	ftnint ciunit;
	flag ciend;
	char *cifmt;
	ftnint cirec;
} cilist;

/*internal read, write*/
typedef struct
{	flag icierr;
	char *iciunit;
	flag iciend;
	char *icifmt;
	ftnint icirlen;
	ftnint icirnum;
} icilist;

/*open*/
typedef struct
{	flag oerr;
	ftnint ounit;
	char *ofnm;
	ftnlen ofnmlen;
	char *osta;
	char *oacc;
	char *ofm;
	ftnint orl;
	char *oblnk;
} olist;

/*close*/
typedef struct
{	flag cerr;
	ftnint cunit;
	char *csta;
} cllist;

/*rewind, backspace, endfile*/
typedef struct
{	flag aerr;
	ftnint aunit;
} alist;

/* inquire */
typedef struct
{	flag inerr;
	ftnint inunit;
	char *infile;
	ftnlen infilen;
	ftnint	*inex;	/*parameters in standard's order*/
	ftnint	*inopen;
	ftnint	*innum;
	ftnint	*innamed;
	char	*inname;
	ftnlen	innamlen;
	char	*inacc;
	ftnlen	inacclen;
	char	*inseq;
	ftnlen	inseqlen;
	char 	*indir;
	ftnlen	indirlen;
	char	*infmt;
	ftnlen	infmtlen;
	char	*inform;
	ftnint	informlen;
	char	*inunf;
	ftnlen	inunflen;
	ftnint	*inrecl;
	ftnint	*innrec;
	char	*inblank;
	ftnlen	inblanklen;
} inlist;

#define VOID void

union Multitype {	/* for multiple entry points */
	integer1 g;
	shortint h;
	integer i;
	/* longint j; */
	real r;
	doublereal d;
	complex c;
	doublecomplex z;
	};

typedef union Multitype Multitype;

/*typedef long int Long;*/	/* No longer used; formerly in Namelist */

struct Vardesc {	/* for Namelist */
	char *name;
	char *addr;
	ftnlen *dims;
	int  type;
	};
typedef struct Vardesc Vardesc;

struct Namelist {
	char *name;
	Vardesc **vars;
	int nvars;
	};
typedef struct Namelist Namelist;

#define abs(x) ((x) >= 0 ? (x) : -(x))
#define dabs(x) (doublereal)abs(x)
#define min(a,b) ((a) <= (b) ? (a) : (b))
#define max(a,b) ((a) >= (b) ? (a) : (b))
#define dmin(a,b) (doublereal)min(a,b)
#define dmax(a,b) (doublereal)max(a,b)
#define bit_test(a,b)	((a) >> (b) & 1)
#define bit_clear(a,b)	((a) & ~((uinteger)1 << (b)))
#define bit_set(a,b)	((a) |  ((uinteger)1 << (b)))

/* procedure parameter types for -A and -C++ */

#define F2C_proc_par_types 1
#ifdef __cplusplus
typedef int /* Unknown procedure type */ (*U_fp)(...);
typedef shortint (*J_fp)(...);
typedef integer (*I_fp)(...);
typedef real (*R_fp)(...);
typedef doublereal (*D_fp)(...), (*E_fp)(...);
typedef /* Complex */ VOID (*C_fp)(...);
typedef /* Double Complex */ VOID (*Z_fp)(...);
typedef logical (*L_fp)(...);
typedef shortlogical (*K_fp)(...);
typedef /* Character */ VOID (*H_fp)(...);
typedef /* Subroutine */ int (*S_fp)(...);
#else
typedef int /* Unknown procedure type */ (*U_fp)();
typedef shortint (*J_fp)();
typedef integer (*I_fp)();
typedef real (*R_fp)();
typedef doublereal (*D_fp)(), (*E_fp)();
typedef /* Complex */ VOID (*C_fp)();
typedef /* Double Complex */ VOID (*Z_fp)();
typedef logical (*L_fp)();
typedef shortlogical (*K_fp)();
typedef /* Character */ VOID (*H_fp)();
typedef /* Subroutine */ int (*S_fp)();
#endif
/* E_fp is for real functions when -R is not specified */
typedef VOID C_f;	/* complex function */
typedef VOID H_f;	/* character function */
typedef VOID Z_f;	/* double complex function */
typedef doublereal E_f;	/* real function with -R not specified */

/* undef any lower-case symbols that your C compiler predefines, e.g.: */

#ifndef Skip_f2c_Undefs
/* (No such symbols should be defined in a strict ANSI C compiler.
   We can avoid trouble with f2c-translated code by using
   gcc -ansi [-traditional].) */
#undef cray
#undef gcos
#undef mc68010
#undef mc68020
#undef mips
#undef pdp11
#undef sgi
#undef sparc
#undef sun
#undef sun2
#undef sun3
#undef sun4
#undef u370
#undef u3b
#undef u3b2
#undef u3b5
#undef unix
#undef vax
#endif
#endif


/* Table of constant values */




static int pcgs(doublereal *d__, doublereal *a, integer *ia, 
	integer *n, integer *n1, integer *nl, doublereal *b, doublereal *eps, 
	integer *itr, doublereal *s, doublereal *x, doublereal *dd, 
	doublereal *p, doublereal *q, doublereal *r__, doublereal *r0, 
	doublereal *e, doublereal *h__, doublereal *w, integer *m, integer *
	ier)
{
    /* System generated locals */
    integer a_dim1, a_offset, ia_dim1, ia_offset, i__1, i__2, i__3;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
	    e_wsle(void);
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, j, k;
    static doublereal y, c1, c2, c3, x1, x2, th;
    static integer nn;
    static doublereal ss, sw, res, beta, alpha;

    /* Fortran I/O blocks */


/* ********************************************************************** */
/*  CONJUGATE GRADIENT SQURED METHOD WITH INCOMPLETE LU DECOMPOSITION. * */
/*                                                                     * */
/*  PARAMETERS: SAME AS ROUTINE PCG EXCEPT A AND IA.                   * */
/*   ON ENTRY:                                                         * */
/*     A      NON-ZERO ELEMENTS OF THE LOWER TRIANGULAR PART OF THE    * */
/*            MATRIX A INTO 1-ST TO NL-TH POSITION OF THE ARRAY A.     * */
/*            NON-ZERO ELEMENTS OF THE UPPER TRIANGULAR PART OF THE    * */
/*            MATRIX A INTO NL+1-ST TO 2*NL-TH POSITION OF THE ARRAY A.* */
/*     IA     COLUMN INDEX OF CORRESPONDING ELEMENT IN THE ARRAY A.    * */
/*   OTHERS:  WORKING PARAMETERS.                                      * */
/*                                                                     * */
/*  COPYRIGHT:     TSUTOMU OGUNI       FEB. 1 1993      VER. 2         * */
/* ********************************************************************** */

    /* Parameter adjustments */
    --m;
    --h__;
    --e;
    --r0;
    --b;
    --d__;
    ia_dim1 = *n1;
    ia_offset = 1 + ia_dim1;
    ia -= ia_offset;
    a_dim1 = *n1;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *ier = 0;
    if (*n1 < *n || *s < 0.f) {






	;
	*ier = 2;
	return 0;
    }

    th = 1.;
    if (*s > 0.f && *s < 1.f) {
	th = *s;
	*s = 1.;
    }
    i__1 = *n << 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L5: */
	m[i__] = 0;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	dd[i__] = 0.;
	i__2 = *nl;
	for (j = 1; j <= i__2; ++j) {
	    if (ia[i__ + j * ia_dim1] != 0) {
		++m[i__];
	    }
/* L7: */
	}
	i__2 = *nl << 1;
	for (j = *nl + 1; j <= i__2; ++j) {
	    if (ia[i__ + j * ia_dim1] != 0) {
		++m[i__ + *n];
	    }
/* L8: */
	}
/* L6: */
    }
    dd[0] = 0.;
    x[0] = 0.;
    p[0] = 0.;
    q[0] = 0.;
    r__[0] = 0.;
    w[0] = 0.;
/*  INCOMPLETE CHOLESKY DECOMPOSITION */
    if (*s != 0.f) {
	dd[1] = 1. / (*s * d__[1]);
	i__1 = *n;
	for (i__ = 2; i__ <= i__1; ++i__) {
	    ss = *s * d__[i__];
	    i__2 = m[i__];
	    for (k = 1; k <= i__2; ++k) {
		sw = 0.;
		nn = ia[i__ + k * ia_dim1];
		if (nn != 0) {
		    i__3 = *nl + m[nn + *n];
		    for (j = *nl + 1; j <= i__3; ++j) {
			if (ia[nn + j * ia_dim1] != i__) {
			    sw += a[nn + j * a_dim1] * th;
			} else {
			    sw += a[nn + j * a_dim1];
			}
/* L17: */
		    }
		}
/* L16: */
		ss -= a[i__ + k * a_dim1] * sw * dd[nn];
	    }
/* L15: */
	    dd[i__] = 1. / ss;
	}
    } else {
	dd[1] = 1. / d__[1];
	i__1 = *n;
	for (i__ = 2; i__ <= i__1; ++i__) {
	    ss = d__[i__];
	    i__2 = m[i__];
	    for (k = 1; k <= i__2; ++k) {
		nn = ia[i__ + k * ia_dim1];
		i__3 = *nl + m[nn + *n];
		for (j = *nl + 1; j <= i__3; ++j) {
		    if (ia[nn + j * ia_dim1] == i__) {
			ss -= a[i__ + k * a_dim1] * a[nn + j * a_dim1] * dd[
				nn];
		    }
/* L22: */
		}
/* L21: */
	    }
/* L20: */
	    dd[i__] = 1. / ss;
	}
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	q[i__] = d__[i__] * x[i__];
	i__2 = m[i__];
	for (j = 1; j <= i__2; ++j) {
/* L32: */
	    q[i__] += a[i__ + j * a_dim1] * x[ia[i__ + j * ia_dim1]];
	}
	i__2 = *nl + m[i__ + *n];
	for (j = *nl + 1; j <= i__2; ++j) {
/* L34: */
	    q[i__] += a[i__ + j * a_dim1] * x[ia[i__ + j * ia_dim1]];
	}
/* L30: */
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L40: */
	r__[i__] = b[i__] - q[i__];
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = m[i__];
	for (j = 1; j <= i__2; ++j) {
/* L52: */
	    r__[i__] -= a[i__ + j * a_dim1] * r__[ia[i__ + j * ia_dim1]];
	}
/* L50: */
	r__[i__] *= dd[i__];
    }
    for (i__ = *n; i__ >= 1; --i__) {
	sw = 0.;
	i__1 = *nl + m[i__ + *n];
	for (j = *nl + 1; j <= i__1; ++j) {
/* L62: */
	    sw += a[i__ + j * a_dim1] * r__[ia[i__ + j * ia_dim1]];
	}
/* L60: */
	r__[i__] -= dd[i__] * sw;
    }
    c1 = 0.;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	r0[i__] = r__[i__];
	p[i__] = r__[i__];
	e[i__] = r__[i__];
/* L70: */
	c1 += r__[i__] * r__[i__];
    }
/*  ITERATION PHASE */
    i__1 = *itr;
    for (k = 1; k <= i__1; ++k) {
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    q[i__] = d__[i__] * p[i__];
	    i__3 = m[i__];
	    for (j = 1; j <= i__3; ++j) {
/* L85: */
		q[i__] += a[i__ + j * a_dim1] * p[ia[i__ + j * ia_dim1]];
	    }
	    i__3 = *nl + m[*n + i__];
	    for (j = *nl + 1; j <= i__3; ++j) {
/* L87: */
		q[i__] += a[i__ + j * a_dim1] * p[ia[i__ + j * ia_dim1]];
	    }
/* L80: */
	}
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    i__3 = m[i__];
	    for (j = 1; j <= i__3; ++j) {
/* L95: */
		q[i__] -= a[i__ + j * a_dim1] * q[ia[i__ + j * ia_dim1]];
	    }
/* L90: */
	    q[i__] = dd[i__] * q[i__];
	}
	for (i__ = *n; i__ >= 1; --i__) {
	    sw = 0.;
	    i__2 = *nl + m[i__ + *n];
	    for (j = *nl + 1; j <= i__2; ++j) {
/* L105: */
		sw += a[i__ + j * a_dim1] * q[ia[i__ + j * ia_dim1]];
	    }
/* L100: */
	    q[i__] -= dd[i__] * sw;
	}
	c2 = 0.;
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L110: */
	    c2 += q[i__] * r0[i__];
	}
	if (c2 == 0.f) {
	    *ier = 3;
	    *itr = k;
	    goto L300;
	}
	alpha = c1 / c2;
	c3 = 0.;
	x1 = 0.;
	x2 = 0.;
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    h__[i__] = e[i__] - alpha * q[i__];
/* L120: */
	}
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L130: */
	    w[i__] = e[i__] + h__[i__];
	}
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    q[i__] = d__[i__] * w[i__];
	    i__3 = m[i__];
	    for (j = 1; j <= i__3; ++j) {
/* L142: */
		q[i__] += a[i__ + j * a_dim1] * w[ia[i__ + j * ia_dim1]];
	    }
	    i__3 = *nl + m[i__ + *n];
	    for (j = *nl + 1; j <= i__3; ++j) {
/* L144: */
		q[i__] += a[i__ + j * a_dim1] * w[ia[i__ + j * ia_dim1]];
	    }
/* L140: */
	}
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    i__3 = m[i__];
	    for (j = 1; j <= i__3; ++j) {
/* L155: */
		q[i__] -= a[i__ + j * a_dim1] * q[ia[i__ + j * ia_dim1]];
	    }
/* L150: */
	    q[i__] = dd[i__] * q[i__];
	}
	for (i__ = *n; i__ >= 1; --i__) {
	    sw = 0.;
	    i__2 = *nl + m[i__ + *n];
	    for (j = *nl + 1; j <= i__2; ++j) {
/* L165: */
		sw += a[i__ + j * a_dim1] * q[ia[i__ + j * ia_dim1]];
	    }
/* L160: */
	    q[i__] -= dd[i__] * sw;
	}
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    y = x[i__];
	    r__[i__] -= alpha * q[i__];
	    x[i__] += alpha * w[i__];
	    c3 += r__[i__] * r0[i__];
	    x1 += y * y;
/* L170: */
/* Computing 2nd power */
	    d__1 = x[i__] - y;
	    x2 += d__1 * d__1;
	}
	if (x1 != 0.f) {
	    res = sqrt(x2 / x1);
	    if (res <= *eps) {
		*itr = k;
		*ier = 0;
		goto L300;
	    }
	}
	if (c1 == 0.f) {
	    *ier = 4;
	    *itr = k;
	    goto L300;
	}
	beta = c3 / c1;
	c1 = c3;
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    e[i__] = r__[i__] + beta * h__[i__];
	    p[i__] = e[i__] + beta * (h__[i__] + beta * p[i__]);
/* L180: */
	}

/* L200: */
    }
    *ier = 1;


    ;
L300:
    *eps = res;
    if (th != 1.) {
	*s = th;
    }
    return 0;
/*  END OF PCGS */
} /* pcgs_ */

